二叉树:
二叉树具有唯一的根节点
二叉树每个节点最多有两个孩子
没有子节点的节点称为叶子节点
二叉树每个节点最多有一个父节点

二分搜索树(B 树):
会进行比较, 最坏的情况会退化成链表

满二叉树: (可以使用数组表示)
除了叶子节点, 所有节点的左右孩子均不为空, 且高度(h)相同
h 层共有 2^h - 1 = n 个节点, 2^h = n + 1  -->  log2(n+1) = h  -->  log(n)

完全二叉树: 查看 heap.png(可以使用数组表示)
在满二叉树的基础上有缺失的节点, 但是缺失是从右下方开始的
所有的元素从左到右, 一层一层的插入到树中, 不用考虑大小
使用数组表示完全二叉树, 可以根据索引计算出孩子节点与父亲节点

            // logn        n
// n = 16       4           16
// n = 1024     10         1024
// n = 100万    20         100万


平衡二叉树: (可以使用数组表示, 但是会存在空间浪费)
平衡二叉树对于整棵树来说, 最大深度和最小深度不会超过1

完全二叉树一定是平衡二叉树

线段树:
线段树不一定是完全二叉树, 是平衡二叉树
线段树(平衡二叉树)可以用数组表示, 但是最后一层会存在缺失的节, 缺失的位置用 null 表示

对满二叉树:
高度 h(从 1 开始计算), 共有 2^h - 1 个节点(大约是 2^h)
最后一层(从 0 开始算 h-1), 有 2^(h-1) 个节点
最后一层的节点数大致等于前面所有层节点之和

如果区间有 n 个元素, 数组表示线段树需要多少节点?

如果 n = 2^k, 那么最后一层的叶子节点恰好平分为 n 个元素, 上层之和为 n-1, 所以只需要开辟 n + n - 1 = 2n 个空间即可
如果 n = 2^k + 1, 是一个奇数节点, 最后一层不足以存储整个节点, 还需要多出一层的空间, 这一层比原来又多了一个 2n, 一共需要 4n 个空间
所以对于最坏情况, 我们使用数组的话需要 4n 个空间来存储, 会存在 null 值, 用空间换取时间, 查看 segment.png

Trie:
字典树, 前缀树, 专门处理字符串, 是一颗多叉树见 trie.png

UnionFind:
并查集, 一种很不一样的树形结构, 由孩子指向父亲的树形结构, 可以非常高效的回答连接问题, 操作的全是根节点, 如果不操作根节点就会退化成链表


AVL树: 最早的自平衡二分搜索树, 解决了二分搜索树退化成链表的问题, 引入了平衡因子的概念, 是一种松散的平衡树(适合查询)
对于任意一个节点, 左子树和右子树的高度差不能超过 1
平衡二叉树的高度和节点数量之间的关系也是O(logn)
标注每一个节点的高度, 叶子节点的高度为 1
计算平衡因子: 左右子树的高度相减 >= 2 代表平衡被破坏

2-3 树: 满足二分搜索树的基本性质(绝对平衡的树)
节点可以存放一个元素(2个孩子)或者两个元素(3个孩子)所以称为 2-3 树
添加节点用于是与叶子节点进行融合, 如果变成了 4 个孩子的 4 节点就要向下拆分

红黑树: 最负盛名的平衡树, 是一颗二分搜索树(适合修改)
1. 每个节点或者是红色的, 或者是黑色的
2. 根节点是黑色的
3. 每一个叶子节点(最后的空节点, 不是左右孩子都为空的节点)是黑色的
4. 如果一个节点是红色的, 那么他的孩子节点都是黑色的
5. 从任意一个节点到叶子节点, 经过的黑色节点是一样的, 从根节点出发, 最大高度是 2logn -> O(logn)

红黑树与 2-3 树是等价的, 在节点中维护了一个颜色属性, 因为每个元素只有一个父亲节点
如果节点的颜色是红色, 代表该节点和它的父亲节点表示 2-3 树中的三节点, 红色节点一定是向左倾斜的
如果节点的颜色是黑色, 代表普通的节点
